package internal

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"strconv"

	"github.com/gorilla/websocket"
)

func (h *ChatWebSocketHandler) HandleChat(w http.ResponseWriter, r *http.Request) {
	conn, err := upgrader.Upgrade(w, r, nil)
	if err != nil {
		log.Printf("WebSocket upgrade failed: %v", err)
		return
	}
	defer conn.Close()

	log.Printf("HTTP upgraded to WebSocket")

	// Validate token
	token := r.URL.Query().Get("token")
	if token == "" {
		conn.WriteJSON(map[string]string{"error": "missing token"})
		return
	}
	userID, _, err := h.chatUsecase.ValidateTokenWithRedis(token)
	if err != nil {
		conn.WriteJSON(map[string]string{"error": "invalid token: " + err.Error()})
		return
	}
	log.Printf("User %d connected with token", userID)

	// Initial subscription channels from URL query
	groupIDStr := r.URL.Query().Get("group_id")
	var initialChannels []string
	if groupIDStr != "" {
		groupID, err := strconv.Atoi(groupIDStr)
		if err != nil {
			conn.WriteJSON(map[string]string{"error": "invalid group_id"})
			return
		}
		initialChannels = []string{fmt.Sprintf("group:%d", groupID), fmt.Sprintf("user:%d", userID)}
		log.Printf("Initial subscription for user %d to channels: %v", userID, initialChannels)
	} else {
		initialChannels = []string{fmt.Sprintf("user:%d", userID)}
		log.Printf("Initial subscription for user %d to personal channel only", userID)
	}

	// Subscribe to initial channels
	var msgChans []<-chan string
	for _, ch := range initialChannels {
		msgChan, err := h.redisService.SubscribeChannel(ch)
		if err != nil {
			log.Printf("Failed to subscribe to initial channel %s: %v", ch, err)
			conn.WriteJSON(map[string]string{"error": "initial subscription failed: " + err.Error()})
			return
		}
		msgChans = append(msgChans, msgChan)
	}

	// Merge initial channels into a single channel
	msgChan := make(chan string)
	for _, ch := range msgChans {
		go func(c <-chan string) {
			for msg := range c {
				msgChan <- msg
			}
		}(ch)
	}

	// Notify online status and fetch unread messages
	if err := h.useruse.SetUserState(userID, "online"); err != nil {
		log.Printf("Failed to update status for user %d: %v", userID, err)
	}
	unreadMessages, err := h.chatUsecase.GetUnreadMessages(userID)
	if err != nil {
		log.Printf("Failed to fetch unread messages for user %d: %v", userID, err)
	} else {
		for _, msg := range unreadMessages {
			if err := conn.WriteJSON(msg); err != nil {
				log.Printf("Failed to send unread message to user %d: %v", userID, err)
			}
		}
	}

	// Handle Redis messages in a separate goroutine
	go func() {
		log.Printf("Starting Redis listener goroutine for user %d", userID)
		for msg := range msgChan {
			log.Printf("Received from Redis for user %d on channels %v: %s", userID, initialChannels, msg)

			var data map[string]interface{}
			if err := json.Unmarshal([]byte(msg), &data); err != nil {
				log.Printf("Failed to unmarshal Redis message for user %d: %v, raw: %s", userID, err, msg)
				continue
			}
			log.Printf("Unmarshalled Redis message for user %d: %#v", userID, data)

			if err := conn.WriteJSON(data); err != nil {
				log.Printf("Failed to send Redis message to user %d: %v", userID, err)
				continue
			}
			log.Printf("Successfully sent Redis message to user %d", userID)
		}
		log.Printf("Redis listener stopped for user %d", userID)
	}()

	// Handle client messages with dynamic channel updates
	done := make(chan struct{})
	go func() {
		defer close(done)
		for {
			_, clientMsg, err := conn.ReadMessage()
			log.Printf("Received client message from user %d: %s", userID, string(clientMsg))
			if err != nil {
				if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
					log.Printf("WebSocket read error for user %d: %v", userID, err)
				}
				return
			}

			var req struct {
				Type       string  `json:"type"`
				ReceiverID int     `json:"receiver_id,omitempty"`
				GroupID    int     `json:"group_id,omitempty"`
				Content    string  `json:"content"`
				SenderID   int     `json:"sender_id,omitempty"`
				Filename   *string `json:"filename,omitempty"`
				Filetype   *string `json:"filetype,omitempty"`
				ReplyTo    *int    `json:"reply_to,omitempty"`
				ForwardTo  *int    `json:"forward_to,omitempty"`
			}
			if err := json.Unmarshal(clientMsg, &req); err != nil {
				log.Printf("Invalid message format from user %d: %s, error: %v", userID, string(clientMsg), err)
				conn.WriteJSON(map[string]string{"error": "invalid message format"})
				continue
			}

			if req.SenderID == 0 {
				req.SenderID = userID
			} else if req.SenderID != userID {
				conn.WriteJSON(map[string]string{"error": "sender_id mismatch"})
				continue
			}

			switch req.Type {
			case "personal_message", "group_message":
				var err error
				var messageID int
				if req.Type == "personal_message" {
					messageID, err = h.chatUsecase.SendPersonalMessage(token, req.ReceiverID, req.Content)
				} else {
					messageID, err = h.chatUsecase.SendGroupMessage(token, req.GroupID, req.Content)
					log.Printf("Sent group message, messageID: %d to group %d", messageID, req.GroupID)
				}
				if err != nil {
					conn.WriteJSON(map[string]string{"error": "failed to send message: " + err.Error()})
				} else if messageID != 0 {
					h.chatUsecase.UpdateMessageStatus(messageID, "delivered")
					// Update subscription if group_id differs
					newChannel := fmt.Sprintf("group:%d", req.GroupID)
					if !contains(initialChannels, newChannel) {
						log.Printf("Adding new subscription for channel %s", newChannel)
						newMsgChan, err := h.redisService.SubscribeChannel(newChannel)
						if err != nil {
							log.Printf("Failed to subscribe to new channel %s: %v", newChannel, err)
							continue
						}
						go func(c <-chan string) {
							for msg := range c {
								msgChan <- msg
							}
						}(newMsgChan)
						initialChannels = append(initialChannels, newChannel)
					}
				}

			case "audio_message", "image_message", "file_message":
				var receiverID, groupID *int
				if req.ReceiverID != 0 {
					id := req.ReceiverID
					receiverID = &id
				}
				if req.GroupID != 0 {
					id := req.GroupID
					groupID = &id
				}
				if receiverID == nil && groupID == nil {
					conn.WriteJSON(map[string]string{"error": "group_id or receiver_id required"})
					continue
				}
				messageID, err := h.chatUsecase.SendMultimediaMessage(token, req.ReceiverID, req.GroupID, req.Content, *req.Filename, *req.Filetype, req.Type)
				if err != nil {
					conn.WriteJSON(map[string]string{"error": "failed to send multimedia: " + err.Error()})
				} else if messageID != 0 {
					h.chatUsecase.UpdateMessageStatus(messageID, "delivered")
					if groupID != nil {
						newChannel := fmt.Sprintf("group:%d", *groupID)
						if !contains(initialChannels, newChannel) {
							log.Printf("Adding new subscription for channel %s", newChannel)
							newMsgChan, err := h.redisService.SubscribeChannel(newChannel)
							if err != nil {
								log.Printf("Failed to subscribe to new channel %s: %v", newChannel, err)
								continue
							}
							go func(c <-chan string) {
								for msg := range c {
									msgChan <- msg
								}
							}(newMsgChan)
							initialChannels = append(initialChannels, newChannel)
						}
					}
				}

			case "reply":
				if req.ReplyTo == nil || req.Content == "" {
					conn.WriteJSON(map[string]string{"error": "reply_to and content required"})
					continue
				}
				err := h.chatUsecase.SendReplyMessage(token, req.ReceiverID, req.GroupID, req.Content, *req.ReplyTo)
				if err != nil {
					conn.WriteJSON(map[string]string{"error": "failed to send reply: " + err.Error()})
				}
				if req.GroupID != 0 {
					newChannel := fmt.Sprintf("group:%d", req.GroupID)
					if !contains(initialChannels, newChannel) {
						log.Printf("Adding new subscription for channel %s", newChannel)
						newMsgChan, err := h.redisService.SubscribeChannel(newChannel)
						if err != nil {
							log.Printf("Failed to subscribe to new channel %s: %v", newChannel, err)
							continue
						}
						go func(c <-chan string) {
							for msg := range c {
								msgChan <- msg
							}
						}(newMsgChan)
						initialChannels = append(initialChannels, newChannel)
					}
				}

			case "forward":
				if req.ForwardTo == nil || req.Content == "" {
					conn.WriteJSON(map[string]string{"error": "forward_to and content required"})
					continue
				}
				err := h.chatUsecase.ForwardMessage(token, *req.ForwardTo, req.Content)
				if err != nil {
					conn.WriteJSON(map[string]string{"error": "failed to forward message: " + err.Error()})
				}

			case "mark_seen":
				chatType := "user"
				chatID := req.ReceiverID
				if req.GroupID != 0 {
					chatType = "group"
					chatID = req.GroupID
				}
				if err := h.chatUsecase.MarkMessagesAsSeen(chatType, chatID, userID); err != nil {
					conn.WriteJSON(map[string]string{"error": "failed to mark as seen: " + err.Error()})
				}
				if req.GroupID != 0 {
					newChannel := fmt.Sprintf("group:%d", req.GroupID)
					if !contains(initialChannels, newChannel) {
						log.Printf("Adding new subscription for channel %s", newChannel)
						newMsgChan, err := h.redisService.SubscribeChannel(newChannel)
						if err != nil {
							log.Printf("Failed to subscribe to new channel %s: %v", newChannel, err)
							continue
						}
						go func(c <-chan string) {
							for msg := range c {
								msgChan <- msg
							}
						}(newMsgChan)
						initialChannels = append(initialChannels, newChannel)
					}
				}

			case "status_update":
				log.Printf("Status update from user %d: %s", userID, req.Content)
				if err := h.useruse.SetUserState(userID, req.Content); err != nil {
					log.Printf("Failed to update status for user %d: %v", userID, err)
				}

			default:
				log.Printf("Unknown message type from user %d: %s", userID, req.Type)
				conn.WriteJSON(map[string]string{"error": "unknown message type"})
			}
		}
	}()

	// Wait for connection to close
	<-done
	log.Printf("User %d disconnected", userID)
	if err := h.useruse.SetUserState(userID, "offline"); err != nil {
		log.Printf("Failed to update offline status for user %d: %v", userID, err)
	}
}

// Helper function to check if a channel exists in the slice
func contains(slice []string, item string) bool {
	for _, s := range slice {
		if s == item {
			return true
		}
	}
	return false
}
